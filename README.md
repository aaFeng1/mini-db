# MiniDB - A Lightweight Relational Database in C++

## 1.简介

MiniDB 是一个基于c++17 实现的轻量级关系型数据库系统

本项目实现了：

- 页式存储管理
- Buffer Pool
- TableHeap
- SQL 解析与执行
- B+Tree索引
- 等值查询

支持基本SQL：

- CREATE TABLE tablename (colname coltype, ...);
- INSERT INTO tablename VALUES (value1, ...);
- SELECT * FROM tablename;
- CREATE INDEX idx_name ON t(name);
- SELECT * FROM tablename WHERE colname = value;

本项目目前对SQL的限制：

- 建表只支持INT与VARCHAR，并且不支持主键、外键
- 插入不支持数据为空
- 只支持select *
- 创建索引只支持在INT列上创建索引，并且只支持一列为索引列，不支持联合索引
- where只支持等值表达式，并且不支持逻辑运算符例如与、或等等

未来工作：

- B+Tree 删除操作
- where范围查询
- WAL 日志

## 2.System Architecture

系统整体结构如下：

Parser

 ↓

Binder

 ↓

Executor

 ↓

catalog

 ↓

TableHeap/B+Tree Index

 ↓

Buffer Pool

 ↓

Disk Manager

[补一张架构图]

## 3.存储层设计

### 3.1.页内分布

#### 3.1.1数据页

包含页头部，slot数组，以及数据本身（tuple）。slot位于页头部后，往高地址增长，tuple位于页尾，从后往前增长。slot数组用于保存tuple的页内偏移

[补一张数据页结构图片]

#### 3.1.2b+树内部页和叶子页

页头部：保存一些内部页和叶子页共有的信息，例如是否为叶子页，父页页号，当前页键值对数量，键值对最大数量，页号。其中有一个特殊的值保存叶子页链表下一节点页号，只有叶子页使用，内部页不会使用

内部页：维护了一个keytype到pageid的键值对数组，数组使用时不会超过页头部设定的键值对最大数量，索引时不会超过页大小

叶子页：维护了一个keytype到RID的键值对数组

### 3.2.页缓冲池

由于我们需要讲硬盘中的数据加载到内存，因此页缓冲池提供fetch，unpin等接口。页缓冲池维护了内存中的页数组，以及每页的元信息，包括pincount，是否为脏页。替换算法目前使用轮转替换。

### 3.3.TableHeap

tableheap即为表本身，维护了数据页链表，提供一些查询插入接口。并且实现了迭代器TableIterator方便数据遍历

## 4.B+树索引

B+树的结构介绍[补一个链接]

本项目实现了B+树的查询和分裂。在0~9999间每条数据重复10次并且随机排列的表中，全表查询和索引查询的效率如下：

``` 
LightDB ready. Type SQL, or 'quit'.
mini-db> SELECT * FROM t;
+-------------+-------------+
| col1        | col2        |
+-------------+-------------+
| 2769        | 2769        |
| 7975        | 7975        |
| 5267        | 5267        |
| 5944        | 5944        |
| 280         | 280         |
| 1445        | 1445        |
| 6109        | 6109        |
| 1341        | 1341        |
| 6339        | 6339        |
| 4304        | 4304        |
| 2835        | 2835        |
| ...         | ...         |
+-------------+-------------+
(100000 rows)
(time: 96.9438 ms)
mini-db> SELECT * FROM t WHERE col1 = 1;
+-------------+-------------+
| col1        | col2        |
+-------------+-------------+
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
+-------------+-------------+
(10 rows)
(time: 109.87 ms)
mini-db> CREATE INDEX idx ON t(col1);
OK (create index)
mini-db> SELECT * FROM t WHERE col1 = 1;
SelectExecutor: using index idx
+-------------+-------------+
| col1        | col2        |
+-------------+-------------+
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
| 1           | 1           |
+-------------+-------------+
(10 rows)
(time: 0.343744 ms)
mini-db> 
```

## 5.Build

``` bash
git clone --recursive https://github.com/aaFeng1/mini-db.git
mkdir build
cd build
cmake ..
make
```

## 6.项目学习收获

由于我在完成这个项目的时候总是有很多疑惑，我会问，我会抱怨，所以收获就以对话的形式来记录了，当然有些是一条条的技巧。

>Q：为什么我总是写出带很多bug的代码，总是会漏。我没有一个合理的流程来编码
>
>A：工程能力就是：人脑不适合同时维护多个状态，工程的解法不是更专注，而是“把专注外包给流程”。比如：1.写验收标准 2.维护出状态集合（状态机） 3.写不变量清单 4.先写伪代码 5.危险步骤封装为小函数 6.写断言 7.尖锐的3个测试。位于某个流程只需要想目前这个步骤的内容，而不是同时思考状态机，哪里加锁，c++语法，测试要写什么。

> Q：在实现bufferpool之后实现表功能的时候，我完全不知道该干什么
>
> A：是的，该模仿已有设计了

> Q：由于项目是毕设，并且完全没必要做的这么难，而且这个东西每一步都做对做好了，什么也没发生，就正常。做错一点直接爆，就导致正反馈很少，并且会怀疑自己好像什么都没做，然后又累又难受
>
> A：在状态不好的时候，应该写todaylist，记录我目前做了什么，写的细一点。而不是让大脑感觉我好像什么都没做。

> Q：（最开始的时候，在刚创建文件夹的时候）我还是不知道该干什么
>
> A：我们应该先做一个最小的可执行的版本，第一版的代码的作用就是用来指示你第二版往哪里走。第一版需要一个能跑，简陋，甚至丑陋的代码，甚至里面的每行代码都会被替换，那就是第一版的代码，写优化美化是后面的事情。

> 文档也很重要！像这种结构不会出现很大变化的代码真得写文档，就像是欠款，每次顺手还一点，最后不会太吃力。很多一起还就很累

> 对“用户输入/运行时可能发生”的错误 → 用 throw 或返回 error
>
> 对“程序员写错调用协议”的错误 → 用 assert

> 请一定一定先自己列清状态机，不要直接拿ai代码，然后读，这是不好的，因为思路会被绕进去，使得代码看起来都对

> 测试太重要了，这使得我不用怀疑其他模块的正确性