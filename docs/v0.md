## minidb-v0版本文档

### 项目背景与目标（Why）

本项目旨在实现一个轻量级的关系型数据库原型系统，用于加深对数据库底层存储与执行机制的理解。

与直接使用现有数据库系统不同，本项目从零开始实现 Page 管理、BufferPool、TableHeap 以及最基本的 SQL 执行流程，以理解数据库系统从磁盘到内存、再到查询执行的完整工作过程。

项目的目标并非实现一个功能完备的数据库，而是通过逐步演进的方式，构建一个结构清晰、可运行的最小系统，并在此基础上进行功能扩展。

### v0 版本设计目标与假设（What）

1.v0版本的目标

v0版本的主要设计目标是：

- 从0到1跑通一个最小可运行的数据库系统
- 验证整体架构设计的可行性
- 支持最基本的数据插入与顺序查询

2.v0的功能范围

再v0版本中，系统支持以下功能：

- 基于 Page 的磁盘存储模型

- 简单的BufferPool，用于管理内存中的页面

- 基于 TableHeap 的表存储结构

- 使用 RID（Record Identifier）对记录进行物理定位

- 支持 `insert` 和 `select *` 两种 SQL 操作

3.v0的设计假设

为了降低系统复杂度、专注于核心流程的实现，v0版本在设计上做出如下假设：

- 系统仅支持单表
- 页号连续分配，从0开始
- 固定的表结构
- 不支持并发与事务，仅在单线程模式下运行
- 不考虑崩溃恢复与日志

上述假设使得系统可以在保持结构清晰的前提下，完成最小功能闭环，为后续版本的扩展奠定基础。

### 系统整体架构（How - 总体）

整体架构如下：

``` 
SQL
 ↓
ExecuteSQL
 ↓
TableHeap
 ↓
TablePage
 ↓
BufferPool
 ↓
Disk
```

系统整体采用分层架构设计。上层负责 SQL 解析，中间层负责表级数据管理，下层负责页级数据存储与缓冲管理。各模块之间通过清晰的接口进行交互，避免了模块间的强耦合。

### 核心模块设计（How - 关键点）

1.Page与BufferPool

由于minidb是持久化的，因此所有数据需要保存到硬盘中，因此会产生读写文件的需求。由于直接读写文件速度很慢，极大影响性能，因此需要先将硬盘内容复制到内存中，在内存中读写，然后如果有修改，再写回硬盘。

我们将内存和磁盘在逻辑上划为一块块固定大小的Page，并且由BufferPool管理将硬盘Page加载到内存的位置，以及脏页写回。同时BufferPool使用pin/unpin标记页面使用情况，使得当某页在使用时不会覆盖它。

2.TablePage与TableHeap

我们在拿到内存中的Page后，本质是一个字节数组，我们将其转换为TablePage，TablePage定义页内布局，包括页头和数据行的安排。TableHeap以链表方式组织多个TablePage。插入数据采用追加写策略，页漫自动扩容。

3.RID设计

RID=(page_id, slot_id)

用于定位唯一一条记录。

### 功能展示与运行示例（Result）

运行示例：

``` text
mini-db> insert 1 100
inserted: page=0 slot=0
mini-db> select
page=0 slot=0 | id=1 value=100
mini-db> insert 2 200
inserted: page=0 slot=1
mini-db> insert 3 300
inserted: page=0 slot=2
mini-db> select
page=0 slot=0 | id=1 value=100
page=0 slot=1 | id=2 value=200
page=0 slot=2 | id=3 value=300
mini-db> 
```

上述示例展示了 v0 版本中插入与查询操作的完整执行流程，验证了系统从存储层到执行层的正确性。

### 当前版本限制与后续计划（Limit & Next）

尽管v0版本已经实现最小可运行系统，但仍存在以下限制：

- 查询功能较为简单，仅支持顺序扫描
- 不支持删除、更新及索引
- 系统假设单线程运行

在后续版本中，计划逐步引入：

- 更复杂的查询条件（如 WHERE）
- 更规范的执行器结构
- 索引与事务支持（视时间情况）

